import { jsPDF } from 'jspdf';
import * as XLSX from 'xlsx';

// Export utilities for reports and data
export const exportUtils = {
  // Export to CSV
  exportToCSV: (data: any[], filename: string) => {
    if (data.length === 0) {
      console.warn('No data to export');
      return;
    }
    
    const headers = Object.keys(data[0]);
    const csvContent = [
      headers.join(','),
      ...data.map(row => 
        headers.map(header => {
          const value = row[header];
          // Handle values that might contain commas or quotes
          if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value || '';
        }).join(',')
      )
    ].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `${filename}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  },

  // Export to Excel
  exportToExcel: (data: any[], filename: string) => {
    if (data.length === 0) {
      console.warn('No data to export');
      return;
    }

    const worksheet = XLSX.utils.json_to_sheet(data);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');
    
    // Auto-size columns
    const colWidths = Object.keys(data[0]).map(key => ({
      wch: Math.max(
        key.length,
        ...data.map(row => String(row[key] || '').length)
      )
    }));
    worksheet['!cols'] = colWidths;

    XLSX.writeFile(workbook, `${filename}.xlsx`);
  },

  // Export to PDF
  exportToPDF: async (content: string, filename: string, data?: any[]) => {
    const pdf = new jsPDF();
    
    // Add header
    pdf.setFontSize(20);
    pdf.setTextColor(59, 130, 246); // Blue color
    pdf.text('ProjectFlow Report', 20, 30);
    
    // Add generation date
    pdf.setFontSize(10);
    pdf.setTextColor(107, 114, 128); // Gray color
    pdf.text(`Generated on ${new Date().toLocaleDateString()}`, 20, 40);
    
    // Add content
    pdf.setFontSize(12);
    pdf.setTextColor(0, 0, 0); // Black color
    
    if (data && data.length > 0) {
      // Create table from data
      let yPosition = 60;
      const headers = Object.keys(data[0]);
      const columnWidth = 180 / headers.length;
      
      // Headers
      pdf.setFontSize(10);
      pdf.setFont(undefined, 'bold');
      headers.forEach((header, index) => {
        pdf.text(header, 20 + (index * columnWidth), yPosition);
      });
      
      yPosition += 10;
      pdf.setFont(undefined, 'normal');
      
      // Data rows
      data.slice(0, 30).forEach((row, rowIndex) => { // Limit to 30 rows for PDF
        if (yPosition > 270) { // Add new page if needed
          pdf.addPage();
          yPosition = 30;
        }
        
        headers.forEach((header, colIndex) => {
          const value = String(row[header] || '');
          const truncatedValue = value.length > 20 ? value.substring(0, 17) + '...' : value;
          pdf.text(truncatedValue, 20 + (colIndex * columnWidth), yPosition);
        });
        yPosition += 8;
      });
      
      if (data.length > 30) {
        yPosition += 10;
        pdf.setFontSize(8);
        pdf.setTextColor(107, 114, 128);
        pdf.text(`... and ${data.length - 30} more rows`, 20, yPosition);
      }
    } else {
      // Add HTML content as text
      const lines = content.split('\n');
      let yPosition = 60;
      
      lines.forEach(line => {
        if (yPosition > 270) {
          pdf.addPage();
          yPosition = 30;
        }
        
        // Remove HTML tags for PDF
        const cleanLine = line.replace(/<[^>]*>/g, '').trim();
        if (cleanLine) {
          if (cleanLine.startsWith('#')) {
            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.text(cleanLine.replace(/^#+\s*/, ''), 20, yPosition);
            yPosition += 10;
          } else {
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'normal');
            const splitText = pdf.splitTextToSize(cleanLine, 170);
            pdf.text(splitText, 20, yPosition);
            yPosition += splitText.length * 5;
          }
        }
      });
    }
    
    // Add footer
    const pageCount = pdf.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.setTextColor(107, 114, 128);
      pdf.text(`Page ${i} of ${pageCount}`, 20, 285);
      pdf.text('Generated by ProjectFlow', 150, 285);
    }

    pdf.save(`${filename}.pdf`);
  },

  // Generate report content
  generateTaskReport: (tasks: any[]) => {
    return tasks.map(task => ({
      'Task Name': task.name,
      'Status': task.status,
      'Priority': task.priority,
      'Assignee': task.assignee?.name || 'Unassigned',
      'Project': task.project,
      'Due Date': new Date(task.dueDate).toLocaleDateString(),
      'Estimated Hours': task.estimatedHours || 0,
      'Actual Hours': task.actualHours || 0,
      'Progress': task.status === 'Complete' ? '100%' : 
                 task.status === 'In progress' ? '50%' : '0%',
      'Created': new Date(task.createdAt).toLocaleDateString(),
      'Updated': new Date(task.updatedAt).toLocaleDateString()
    }));
  },

  generateProjectReport: (projects: any[]) => {
    return projects.map(project => ({
      'Project Name': project.name,
      'Status': project.status,
      'Priority': project.priority,
      'Manager': project.manager?.name || 'Unassigned',
      'Progress': `${project.progress}%`,
      'Budget': `$${project.budget.toLocaleString()}`,
      'Spent': `$${project.spent.toLocaleString()}`,
      'Remaining': `$${(project.budget - project.spent).toLocaleString()}`,
      'Utilization': `${((project.spent / project.budget) * 100).toFixed(1)}%`,
      'Start Date': new Date(project.startDate).toLocaleDateString(),
      'End Date': new Date(project.endDate).toLocaleDateString(),
      'Team Size': project.team?.length || 0,
      'Created': new Date(project.createdAt).toLocaleDateString()
    }));
  },

  generateUserReport: (users: any[]) => {
    return users.map(user => ({
      'Name': user.name,
      'Email': user.email,
      'Role': user.role,
      'Department': user.department,
      'Status': user.status,
      'Last Login': new Date(user.lastLogin).toLocaleDateString(),
      'Created': new Date(user.createdAt).toLocaleDateString()
    }));
  },

  generateTimeReport: (timeEntries: any[]) => {
    return timeEntries.map(entry => ({
      'Task': entry.taskName || 'Unknown',
      'User': entry.userName || 'Unknown',
      'Duration': `${Math.floor(entry.duration / 60)}h ${entry.duration % 60}m`,
      'Billable': entry.billable ? 'Yes' : 'No',
      'Rate': entry.hourlyRate ? `$${entry.hourlyRate}/hr` : 'N/A',
      'Total': entry.billable && entry.hourlyRate ? `$${((entry.duration / 60) * entry.hourlyRate).toFixed(2)}` : 'N/A',
      'Date': new Date(entry.startTime).toLocaleDateString(),
      'Description': entry.description || 'No description'
    }));
  },

  generateOverviewReport: (tasks: any[], projects: any[], users: any[]) => {
    const completedTasks = tasks.filter(t => t.status === 'Complete').length;
    const activeProjects = projects.filter(p => p.status === 'Active').length;
    const totalBudget = projects.reduce((sum, p) => sum + p.budget, 0);
    const totalSpent = projects.reduce((sum, p) => sum + p.spent, 0);

    return [
      {
        'Metric': 'Total Tasks',
        'Value': tasks.length,
        'Details': `${completedTasks} completed, ${tasks.length - completedTasks} remaining`
      },
      {
        'Metric': 'Active Projects',
        'Value': activeProjects,
        'Details': `${projects.length} total projects`
      },
      {
        'Metric': 'Team Members',
        'Value': users.filter(u => u.status === 'Active').length,
        'Details': `${users.length} total users`
      },
      {
        'Metric': 'Budget Utilization',
        'Value': `${((totalSpent / totalBudget) * 100).toFixed(1)}%`,
        'Details': `$${totalSpent.toLocaleString()} of $${totalBudget.toLocaleString()}`
      },
      {
        'Metric': 'Task Completion Rate',
        'Value': `${((completedTasks / tasks.length) * 100).toFixed(1)}%`,
        'Details': `${completedTasks} out of ${tasks.length} tasks completed`
      }
    ];
  }
};